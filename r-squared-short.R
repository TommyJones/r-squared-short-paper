# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit r-squared-short.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE, cache = FALSE, message = FALSE)

options(tinytex.verbose = TRUE)

library(tidyverse)
# library(kableExtra)


## ----geometricgraphic, fig.cap = "Visualizing the geometric interpretation of R-squared. Sum up the squared length of each line segment for the total (left) or residual (right) sums of squares. This figure corresponds to an R-squared of 0.87", fig.asp = .55, fig.alt = "Visualizing the geometric interpretation of R-squared. Sum up the squared length of each line segment for the total (left) or residual (right) sums of squares. This figure corresponds to an R-squared of 0.87"----
set.seed("8675309")

# Generate sample data poings
mymat <- data.frame(y1=rnorm(n=5, mean=5, sd=3), y2=rnorm(n=5, mean=3, sd=5))

# Generate "predicted" values by adding jitter
mymat$y1hat <- jitter(mymat$y1, factor=10)
mymat$y2hat <- jitter(mymat$y2, factor=10)

# Calculate mean point
mymat$y1bar <- mean(mymat$y1)
mymat$y2bar <- mean(mymat$y2)

# Calculate sums of squares
ssres <- sapply(1:nrow(mymat), function(j){
  (mymat$y1[ j ] -mymat$y1hat[ j ])^2 + (mymat$y2[ j ] - mymat$y2hat[ j ])^2
})

sst <- sapply(1:nrow(mymat), function(j){
  (mymat$y1[ j ] -mymat$y1bar[ j ])^2 + (mymat$y2[ j ] - mymat$y2bar[ j ])^2
})

ssm <- sapply(1:nrow(mymat), function(j){
  (mymat$y1bar[ j ] -mymat$y1hat[ j ])^2 + (mymat$y2bar[ j ] - mymat$y2hat[ j ])^2
})

# plot those suckers
par(mfrow = c(1, 2))

plot(mymat[ , c("y1", "y2" ) ], yaxt="n", xaxt="n", pch=19, col=rgb(1,0,0,0.5), 
     ylim=c(min(c(mymat$y2, mymat$y2hat)),max(mymat$y2, mymat$y2hat)),
     xlim=c(min(c(mymat$y1, mymat$y1hat)),max(mymat$y1, mymat$y1hat)),
     main="Total Sum of Squares")
points(mymat[ , c("y1bar", "y2bar") ], pch=19)
for(j in 1:nrow(mymat)){
  lines(c(mymat$y1[ j ],mymat$y1bar[ j ]), c(mymat$y2[ j ],mymat$y2bar[ j ]))
}


plot(mymat[ , c("y1", "y2" ) ], yaxt="n", xaxt="n", pch=19, col=rgb(1,0,0,0.5), 
     ylim=c(min(c(mymat$y2, mymat$y2hat)),max(mymat$y2, mymat$y2hat)),
     xlim=c(min(c(mymat$y1, mymat$y1hat)),max(mymat$y1, mymat$y1hat)),
     main="Sum of Squared Errors")
points(mymat[ , c("y1hat", "y2hat") ], pch=17, col=rgb(0,0,1,0.5))
for(j in 1:nrow(mymat)){
  lines(c(mymat$y1[ j ],mymat$y1hat[ j ]), c(mymat$y2[ j ],mymat$y2hat[ j ]))
}

# 1 - sum(ssres)/sum(sst)


## ----bivar--------------------------------------------------------------------

ami <- read_rds(
  "data-derived/multivariate-ami.rds"
)

options(knitr.kable.NA = '')

ami |>
  select(
    Model = model,
    `R-Squared` = r2,
    `Pct. Change from Single Predictor` = pct_change_from_single
  ) |>
  knitr::kable(
    digits = 3,
    caption = "R-squared for Bivariate Response Regression",
    
  )




## ----M4-----------------------------------------------------------------------

pulp <- read_rds(
  "data-derived/multivariate-pulp.rds"
)

options(knitr.kable.NA = '')

pulp |>
  select(
    Model = model,
    `R-Squared` = r2,
    `Pct. Change from Single Predictor` = pct_change_from_single
  ) |>
  knitr::kable(
    digits = 3,
    caption = "R-squared for Quadruple Response Regression"
  )





## ----ffr----------------------------------------------------------------------

ffr <- read_rds("data-derived/functional-data-analysis-r2.rds")

options(knitr.kable.NA = '')

ffr |>
  select(
    Name = name,
    `R-Squared` = r2
  ) |>
  knitr::kable(  
    digits = 3,
    caption = "R-squared for Function on Function Regression"
  ) 



## ----topicmodeltable----------------------------------------------------------

model_summaries <- 
  read_rds("data-derived/sbir-model-summaries.rds")

model_r2 <- 
  read_rds("data-derived/sbir-topic-models-r2.rds") |>
  mutate(
    model = 1:2
  )

table <- 
  model_summaries |> 
  group_by(model) |>
  filter(
    part_r2 == max(part_r2) | part_r2 == min(part_r2)
  ) |>
  inner_join(
    model_r2
  )

table |>
  ungroup() |>
  mutate(
    top_terms = top_terms |>
      str_split(",") |>
      map(function(x){
        paste(x[1:3], collapse = ",")
      }) |>
      unlist()
  ) |> 
  select(
    `Model size` = k, 
    `R-sq.` = r2, 
    Topic = topic, 
    Prevalence = prevalence, 
    `Part R-sq.` = part_r2, 
    `Top 3 words` = top_terms
  ) |>
  knitr::kable(  
    digits = 3,
    caption = "$R^2$ for two SBIR topic models."
  ) 

# |>
  # kableExtra::collapse_rows(1:2)


## ----selecttopics, fig.cap = "Using R-squared to select the number of topics. Results are mixed. There is neither a peak, nor does the curve monotonically increase.", fig.width = 6, fig.height = 3, fig.alt = "A line chart using R-squared as a selection criteria for the number of topics. Results are mixed. There is neither a peak, nor does the curve monotonically increase."----

est_k <- read_rds("data-derived/sbir-model-selection.rds")

est_k$est_k |> 
  ggplot(aes(x = k, y = r2)) + 
  geom_line(lwd = 1.3) +
  ggtitle("") +
  ylab("R-squared") +
  xlab("Number of topics")



## ----echo = TRUE--------------------------------------------------------------
library(mvrsquared)
data(mtcars)
# fit a linear model
f <- lm(mpg ~ cyl + disp + hp + wt, data = mtcars)
# extract r-squared for comparison
f_summary <- summary(f)
r2_lm <- f_summary$r.squared
r2_lm
# calculate univariate r-squared using mvrsquared
r2_mv <- calc_rsquared(y = mtcars$mpg, yhat = f$fitted.values)
r2_mv
# just to be 100% sure...
r2_lm == r2_mv


## ----echo = TRUE--------------------------------------------------------------
x <- cbind(1, f$model[, -1]) # note, you have to add 1's for the intercept and
# I'm removing the first column of f$model as it
# is the outcome we are predicting
x <- as.matrix(x) # x needs to be a matrix, not a data.frame or tibble 
w <- matrix(f$coefficients, ncol = 1) # w also has to be a matrix
# this calculates yhat as the dot product x %*% w
r2_mv2 <- calc_rsquared(
  y = mtcars$mpg, 
  yhat = list(x = x, w = w)
)
r2_mv2


## ----echo = TRUE--------------------------------------------------------------
r2_mv2 == r2_lm


## ----echo = TRUE--------------------------------------------------------------
round(r2_mv2, 14) == round(r2_lm, 14)


## ----echo = TRUE--------------------------------------------------------------
batch_size <- 10
batches <- lapply(
  X = seq(1, nrow(mtcars), by = batch_size),
  FUN = function(b){
    # rows to select on
    rows <- b:min(b + batch_size - 1, nrow(mtcars))
    # rows of the dtm
    y_batch <- mtcars$mpg[rows]
    # rows of theta multiplied by document length
    x_batch <- x[rows, ]
    # return result
    list(
      y = y_batch,
      x = x_batch
    )
  }
)
# calculate ybar for the data
# in this case, lazily doing colMeans, but you could divide this problem up too
ybar <- mean(mtcars$mpg)
# MAP: calculate sums of squares
ss <- lapply(
  X = batches,
  FUN = function(batch){
    calc_rsquared(
      y = batch$y,
      yhat = list(x = batch$x, w = w),
      ybar = ybar,
      return_ss_only = TRUE
    )
  }
)
# REDUCE: get SST and SSE by summation
ss <- do.call(rbind, ss) 
ss <- colSums(ss)
r2_mapreduce <- 1 - ss["sse"] / ss["sst"]
# should be the same as above
r2_mapreduce

